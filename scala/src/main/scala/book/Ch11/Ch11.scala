package book.Ch11

object Ch11 extends App{
  // операторы.
  // левоассоциативные - читаем слева направо, как обычно. Правоассоциативные - справа налево, например присваивание или 2 :: 1 :: Nil
  // 2 :: Nil - правоассоциативный двухместный оператор. Nil.::(2)

  // apply и update
  // Если f не является функцией или методом, тогда выражение f(arg1, arg2, ...) будет эквивалентно f.apply(arg1, arg2, ...)
  // если оно не находится слева от оператора присвоения.
  // Выражение f(arg1, arg2, ...) = value соответствует вызову f.update(arg1, arg2, ..., value)
  // Метод apply также часто используется в объектах-компаньонах для конструирования объектов без использования ключевого слова new

  // Экстрактор – это объект с методом unapply. Метод unapply принимает объект и извлекает из него
  // значения, обычно на основе которых был сконструирован объект. 

  class Fraction(private val n: Int,private val d: Int) {
    def *(other: Fraction) = new Fraction(n * other.n, d * other.d)
  }

  object Fraction {
    def apply(n: Int, d: Int) = new Fraction(n, d)

    def unapply(input: Fraction) = if (input.d == 0) None else Some((input.n, input.d))
  }

  var Fraction(a, b) = Fraction(3, 4) * Fraction(2, 5) // методами apply собираются и результат раскладывается экстрактором в a и b
  // a и b инициализируются значениями числителя и знаменателя результата
  // или в сопоставлении с образцом: case Fraction(a, b) => ... // a, b связываются с числителем и знаменателем
  // val author = "Cay Horstmann"; val Name(first, last) = author // Вызовет Name.unapply(author)
  // Чтобы извлечь произвольную последовательность значений, необходимо вызвать метод unapplySeq.
  // Избегайте определения сразу двух методов, unapply и unapplySeq, с аргументами одного и того же типа.


  // Динамический вызов стр 179
}
