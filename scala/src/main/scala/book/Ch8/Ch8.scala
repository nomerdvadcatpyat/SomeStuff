package Ch8

object Ch8 extends App {
  // Наследование. extends так же как и в джаве. Переопределение методов override def ... .
  // Для проверки принадлежности объекта заданному классу - obj.isInstanceOf[Class] = истинна, если obj имеет тип Class ли его наследник.
  // Лучше использовать паттерн матчинг
  // Для каста - obj.asInstanceOf[Class]; если obj = null, вернет null, если obj не Class и не подкласс Class, то ексепшн.
  // Чтобы убедиться, что obj это именно Class, нужно (obj.getClass == classOf[Class]).
  // protected - как и в джаве, члены доступны только подклассам, НО здесь невидимы в области пакета, которому принадлежит класс
  // protected[this] - ограничить доступность к текущему объекту (??????????????)

  // Конструктор суперкласса можно вызывать ТОЛЬКО из главного конструктора (тк дополнительные всегда должны вызывать либо
  // определенный выше доп конст либо главный конст). Вызов конструктора суперкласса также оказывается вплетенным в
  // определение подкласса: class Employee(name: String, age: Int, val salary : Double) extends Person(name, age).
  // Scala классы могут наследовать Java классы.

  // Можно переопределить поле val (или определение def метода без параметров) другим полем val с тем же именем.
  // Объявление def может переопределить только другое объявление def. объявление var может переопределить только
  // абстрактное объявление var.

  // Анонимные классы как в жаве. Абстрактные классы - abstract class ... {...}, перед методами abstract не нужен,
  // override в подклассах тоже не нужен. Есть абстрактные поля (В сгенерированном абстрактом Java-классе поля отсутствуют.).

  // Опережающее определение:
  // class Creature {  val range: Int = 10  val env: Array[Int] = new Array[Int](range) }
  // class Ant extends Creature {  override val range = 2 }
  // Значение range используется в конструкторе суперкласса, а конструктор суперкласса выполняется перед конструктором подкласса.
  // У Ant env.length = 0 тк range Ant в конструкторе Creature еще не инициализирован.
  // Решение: class Bug extends {  override val range = 2 } with Creature

  // Иерархия наследования: схема - стр 126
  // Все классы в языке Scala реализуют интерфейс-маркер ScalaObject, не имеющий методов.
  // Null – это тип, имеющий единственный экземпляр со значением null. Значение null можно присвоить любой ссылке,
  // и нельзя присвоить переменной никакого другого типа. Например, присвоить null переменной типа Int нельзя.
  // В Java, напротив, значение null можно присвоить обертке Integer.
  // Тип Nothing не имеет экземпляров. Однако его можно использовать для реализации обобщенных конструкций.
  // Тип. Nothing.–.это.не.то.же.самое,.что. void.в.Java.или.C++..
  // В.Scala.тип.void.представлен.типом.Unit,.единственным.значением.которого.является.().
  // переопределяем equals AnyRef, а не ==
  // В прикладных программах обычно не требуется вызывать eq или equals. Достаточно воспользоваться оператором ==.
  // Для ссылочных типов он вызовет метод equals после того, как убедится, что ни один из операндов не равен null.

  // Классы-значения (value classes) - 1. Наследует класс AnyVal.
  // 2. Главный конструктор не имеет тела и принимает точно один параметр val. 3. Не имеет других полей и конструкторов.
  // 4. Автоматически реализует методы equals и hashCode для сравнения и вычисления хеш-кода внутреннего значения.
  // class MilTime(val time: Int) extends AnyVal {  def minutes = time % 100  def hours = time / 100  override def toString = f"$time04d" }



}