package book.Ch17

import java.time.LocalTime

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.DurationInt
import scala.concurrent.{Await, Future}
import scala.math.random
import scala.util.{Failure, Success, Try}

object Ch17 extends App {
  // Футуры и промисы

  //  Future - Это объект, возвращающий результат (или ошибку) в некоторый момент в будущем.

  // Язык Scala помогает организовать вычисления в функциональном стиле. Вычислительная задача возвращает значение
  // когда-нибудь в будущем. Пока в ходе вычислений не производится побочных эффектов, они могут выполняться параллельно,
  // а их результаты – объединяться по мере готовности.

  // Когда создается объект Future, завернутый в него код выполняется в отдельном потоке.
  // Каждый объект Future должен создаваться со ссылкой на экземпляр ExecutionContext.
  // Проще всего этого добиться при помощи инструкции импортирования import ExecutionContext.Implicits.global
  // В этом случае задания будут выполняться в потоках из глобального пула. Он прекрасно подходит для демонстрационных целей,
  // но в действующей программе вам придется выбрать что-то другое, если задания способны блокироваться.

  // Объект Future может возвращать – и обычно возвращает – результат

  // Чтобы дождаться результатов, можно просто выполнить блокирующийся вызов.
  //  import scala.concurrent.duration._
  //  val f = Future { Thread.sleep(10000); 42 }
  //  val result = Await.result(f, 10.seconds)
  // Если задание не завершилось в течение указанного времени, метод Await.ready возбуждает исключение TimeoutException.
  // Если задание возбудило исключение, оно повторно будет возбуждено методом Await.result. Чтобы избежать этого, можно вызвать
  // Await.ready, а затем извлечь результат.
    //  val f = Future { ... }
    //  Await.ready(f, 10.seconds)
    //  val Some(t) = f.value

  // Класс Try. Экземпляр Try[T] может быть или Success(v), где v – значение типа T, или Failure(ex), где ex – Throwable.
    //  val a = Try {
    //    2/0;
    //  }
    //
    //  a match {
    //    case Success(value) => println(value)
    //    case Failure(exception) => println(exception.getMessage);
    //  }


  // Обратные вызовы.
  // В программах редко используются методы ожидания результатов, блокирующие выполнение. Более высокой
  // производительности можно добиться, передавая объектам Future функции, которые должны вызываться по завершении вычислений.
  // Для этого можно использовать метод onComplete: f.onComplete(t => ...) // где t: Try
    //  val f = Future {
    //    Thread.sleep(1000)
    //    if (random < 0.5) throw new Exception()
    //    42
    //  }
    //
    //  f.onComplete {
    //   case Success(v) => println(s"The answer is $v")
    //   case Failure(ex) => println(s"Error ${ex.getMessage}")
    //  }
    //
    //  Thread.sleep(2000)

  // Можно вкладывать обратные вызовы друг в друга, но это крайне неудобно. (Этот прием иногда так и называют: «ад обратных вызовов».)
  // Намного практичнее интерпретировать объекты Future как сущности, которые могут комбинироваться, подобно функциям.
  // Вы можете объединить две функции, вызвав сначала одну, а затем передав ее результат второй.

  // Комбинирование заданий в объектах Future.
  // Пример колбека стр 298.
  // Представьте, что Future – это коллекция с единственным элементом (что, по сути дела, так и есть).
    //  val future1 = Future { getData1() }
    // val future2 = Future { getData2() }
    // val combined = future1.map(n1 => future2.map(n2 => n1 + n2))
  // К сожалению, теперь переменная combined имеет тип Future[Future[Int]], что не очень хорошо.
  // Исправим этот недостаток при помощи flatMap:
    // val combined = f1.flatMap(n1 => f2.map(n2 => n1 + n2))
  // Однако этот код можно еще улучшить, если вместо цепочки вызовов flatMap и map использовать выражение for:
    // val combined = for (n1 <- future1; n2 <- future2) yield n1 + n2
  // Если хотя бы одно задание потерпит неудачу, выполнение конвейера прервется, и в вызывающий код будет
  // возвращено исключение. При использовании приема вложения обратных вызовов об этом придется побеспокоиться на каждом шаге.
  // Если не нравится for/yield, то можно юзать либу https://github.com/scala/scala-async#await-must-be-directly-in-the-control-flow-of-the-async-expression

  // Отложить операцию выполнения футура можно изменив val на def

  // Другие преобразования объектов Future
    // val combined = for (n1 <- future1; n2 <- future2) yield n1 + n2
    // combined.foreach(n => println(s"Result: $n"))
  // Метод recover принимает частично определенную функцию, способную преобразовать исключение в успешный результат.
    // Рассмотрим следующий вызов: val f = Future { persist(data) } recover { case e: SQLException => 0 }
  // Метод fallbackTo реализует другой механизм восстановления после ошибки. Вызов f.fallbackTo(f2) выполнит f2, если f потерпит
  // неудачу, а его результат станет результатом f.
  // Метод failed преобразует объект Future[T], потерпевший неудачу, в успешный объект Future[Throwable], в точности как метод Try.failed.

  // Преобразования объекта Future[T] с результатом v или исключением ex. Таблица на стр 302

  //  Методы объекта Future
  // val result = Future.sequence(futures); Например, пусть futures имеет тип Set[Future[T]]. Тогда результат
  // этого метода будет иметь тип Future[Set[T]]. Когда результаты всех вычислений станут доступны, результатом этого
  // объекта Future станет множество всех результатов.
  // Метод traverse сочетает вызовы методов map и sequence. Следующий код
  //  val futures = parts.map(p => Future { вычислить результат в p })
  //  val result = Future.sequence(futures);
  //  можно записать иначе: val result = Future.traverse(parts)(p => Future { вычислить результат в p })
  // Существуют также методы reduceLeft и foldLeft: val result = Future.reduceLeft(futures)(_ + _)
  // Future[T] result = Future.firstCompletedOf(futures) вы получите объект Future, который будет содержать результат или
  // ошибку первого завершившегося задания из futures.
  // Метод find действует аналогично, но позволяет передать предикат. val result = Future.find(futures)(predicate)
  // Наконец, объект Future поддерживает удобные методы для создания простых объектов Future:
  //  Future.successful(r) – уже завершившийся объект Future с результатом r;
  //  Future.failed(e) – уже завершившийся объект Future с исключением e;
  //  Future.fromTry(t) – уже завершившийся объект Future с результатом или исключением в объекте t типа Try;
  //  Future.unit – уже завершившийся объект Future с результатом Unit;
  //  Future.never – объект Future, который никогда не завершится.

  //  Объекты Promise.
  // Объект Future доступен только для чтения. Значение этого объекта устанавливается неявно, по завершении задания.
  // Объект Promise похож на объект Future, но его значение можно установить явно.
    // def computeAnswer(arg: String) = {
    //  val p = Promise[Int]()
    //  Future {
    //   val n = workHard(arg)
    //   p.success(n)
    //   workOnSomethingElse()
    //  }
    //  p.future
    // }
  // Вызов метода future объекта Promise возвращает ассоциированный объект Future. Обратите внимание, что метод возвращает Future
  // сразу после запуска задания, которое в конечном итоге вернет результат. Это задание выполняется в другом объекте Future, который
  // определяется выражением Future { ... }, то есть не связанном с объектом Future, который возвращает метод future.
  // Вызов метода success объекта Promise устанавливает его результат. Также можно вызвать метод failure с исключением, чтобы получить
  // объект Promise, потерпевший неудачу.
  // Как следует из примера, помимо создания объекта Promise можно сделать еще что-нибудь, например создать еще один объект Promise.
  //  val p1 = Promise[Int]()
  //  val p2 = Promise[Int]()
  //  Future {
  //   val n1 = getData1()
  //   p1.success(n1)
  //   val n2 = getData2()
  //   p2.success(n2)
  //  }
  // Также можно запустить несколько заданий, выполняющихся параллельно и воздействующих на один объект Promise.
  // Когда то или иное задание завершится, оно вызовет метод trySuccess объекта Promise.
  // В отличие от success, этот метод принимает результат и возвращает true, если объект Promise еще не был завершен;
  // иначе он вернет false и проигнорирует результат.
  //      val p = Promise[Int]()
  //      Future {
  //       var n = workHard(arg)
  //       p.trySuccess(n)
  //      }
  //      Future {
  //       var n = workSmart(arg)
  //       p.trySuccess(n)
  //      }
  // Объект Promise будет завершен заданием, первым получившим результат.

  // Контексты выполнения. По умолчанию асинхронные задания Future выполняются в потоках из глобального пула.
  // Это решение хорошо подходит для вычислительных заданий. Однако глобальный пул содержит небольшое количество потоков
  // (по умолчанию равное количеству ядер всех процессоров). Это может вызывать проблемы в случае заданий, большую часть
  // времени проводящих в ожидании, например, ответа от удаленного ресурса.
  // Вы можете известить контекст выполнения, что задание может блокироваться, поместив его в блок blocking { ... }:
  //      val f = Future {
  //       val url = ...
  //       blocking {
  //       val contents = Source.fromURL(url).mkString
  //       ...
  //       }
  //      }
  // Контекст выполнения, в свою очередь, может увеличить количество потоков. Глобальный пул именно так и поступает, но он не
  // предназначен для поддержки большого количества заблокированных потоков выполнения.
  // Если программа должна запускать большое количество заданий, взаимодействующих с базами данных или осуществляющих
  // ввод/вывод, используйте другой пул потоков. Кэширующий пул потоков прекрасно подходит для организации программ,
  // интенсивно выполняющих ввод/ вывод. Его можно явно передать в вызов метода Future.apply или установить как неявный контекст выполнения:
  //    val pool = Executors.newCachedThreadPool()
  //    implicit val ec = ExecutionContext.fromExecutor(pool)
  // Теперь этот пул будет использоваться всеми объектами Future, находящимися в области видимости ec.


  // Упражнения.

  // 2
  def doInOrder[T,U,V](f: T => Future[U], g: U => Future[V]): T => Future[V]= {
    t => f(t).flatMap(ft => g(ft))
  }

  doInOrder((x: Int) => Future {x.toString}, (s: String) => Future {s.charAt(0)})(10) // не понимаю откуда 2 скобки

  // 3
  def doInOrder2[T](fs: (T => Future[T])*): T => Future[T]= {
    
  }

}
